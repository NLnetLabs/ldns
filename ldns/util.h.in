/*
 * util.h
 *  
 * helper function header file
 * 
 * a Net::DNS like library for C
 * 
 * (c) NLnet Labs, 2004
 * 
 * See the file LICENSE for the license
 */

#ifndef _UTIL_H
#define _UTIL_H

#include <stdbool.h>
#include <time.h>

#define dprintf(X,Y) fprintf(stderr, (X), (Y))
/* #define	dprintf(X, Y)  */

#define LDNS_VERSION "@PACKAGE_VERSION@"

/**
 * splint static inline workaround
 */
#ifdef S_SPLINT_S
#define INLINE 
#else
#define INLINE static inline
#endif

/**
 * Memory management macros
 */
#define LDNS_MALLOC(type)		LDNS_XMALLOC(type, 1)

#define LDNS_XMALLOC(type, count)	((type *) malloc((count) * sizeof(type)))

#define LDNS_REALLOC(ptr, type)		LDNS_XREALLOC((ptr), type, 1)

#define LDNS_XREALLOC(ptr, type, count)				\
	((type *) realloc((ptr), (count) * sizeof(type)))

#define LDNS_FREE(ptr) \
	do { free((ptr)); (ptr) = NULL; } while (0)

#define LDNS_DEP     printf("DEPRECATED FUNCTION!\n");

/*
 * Copy data allowing for unaligned accesses in network byte order
 * (big endian).
 */
INLINE uint16_t
ldns_read_uint16(const void *src)
{
#ifdef ALLOW_UNALIGNED_ACCESSES
	return ntohs(*(uint16_t *) src);
#else
	uint8_t *p = (uint8_t *) src;
	return ((uint16_t) p[0] << 8) | (uint16_t) p[1];
#endif
}

INLINE uint32_t
ldns_read_uint32(const void *src)
{
#ifdef ALLOW_UNALIGNED_ACCESSES
	return ntohl(*(uint32_t *) src);
#else
	uint8_t *p = (uint8_t *) src;
	return (  ((uint32_t) p[0] << 24)
		| ((uint32_t) p[1] << 16)
		| ((uint32_t) p[2] << 8)
		|  (uint32_t) p[3]);
#endif
}

/*
 * Copy data allowing for unaligned accesses in network byte order
 * (big endian).
 */
INLINE void
ldns_write_uint16(void *dst, uint16_t data)
{
#ifdef ALLOW_UNALIGNED_ACCESSES
	* (uint16_t *) dst = htons(data);
#else
	uint8_t *p = (uint8_t *) dst;
	p[0] = (uint8_t) ((data >> 8) & 0xff);
	p[1] = (uint8_t) (data & 0xff);
#endif
}

INLINE void
ldns_write_uint32(void *dst, uint32_t data)
{
#ifdef ALLOW_UNALIGNED_ACCESSES
	* (uint32_t *) dst = htonl(data);
#else
	uint8_t *p = (uint8_t *) dst;
	p[0] = (uint8_t) ((data >> 24) & 0xff);
	p[1] = (uint8_t) ((data >> 16) & 0xff);
	p[2] = (uint8_t) ((data >> 8) & 0xff);
	p[3] = (uint8_t) (data & 0xff);
#endif
}

/* warning. */
INLINE void
ldns_write_uint64_as_uint48(void *dst, uint64_t data)
{
	uint8_t *p = (uint8_t *) dst;
	p[0] = (uint8_t) ((data >> 40) & 0xff);
	p[1] = (uint8_t) ((data >> 32) & 0xff);
	p[2] = (uint8_t) ((data >> 24) & 0xff);
	p[3] = (uint8_t) ((data >> 16) & 0xff);
	p[4] = (uint8_t) ((data >> 8) & 0xff);
	p[5] = (uint8_t) (data & 0xff);
}

/** A general purpose lookup table
 *  
 *  Lookup tables are arrays of (id, name) pairs,
 *  So you can for instance lookup the RCODE 3, which is "NXDOMAIN",
 *  and vice versa. The lookup tables themselves are defined wherever needed,
 *  for instance in \ref host2str.h
 */
typedef struct ldns_struct_lookup_table ldns_lookup_table;
struct ldns_struct_lookup_table {
        int id;
        const char *name;
};
  
/**
 * Looks up the table entry by name, returns NULL if not found.
 * \param[in] table the lookup table to search in
 * \param[in] name what to search for
 * \return the item found
 */
ldns_lookup_table *ldns_lookup_by_name(ldns_lookup_table table[],
                                       const char *name);

/**
 * Looks up the table entry by id, returns NULL if not found.
 * \param[in] table the lookup table to search in
 * \param[in] id what to search for
 * \return the item found
 */
ldns_lookup_table *ldns_lookup_by_id(ldns_lookup_table table[], int id);

/**
 * Returns the value of the specified bit
 * The bits are counted from left to right, so bit #0 is the
 * left most bit.
 * \param[in] bits array holding the bits
 * \param[in] index to the wanted bit
 * \return 
 */
int ldns_get_bit(uint8_t bits[], size_t index);


/**
 * Returns the value of the specified bit
 * The bits are counted from right to left, so bit #0 is the
 * right most bit.
 * \param[in] bits array holding the bits
 * \param[in] index to the wanted bit
 * \return 1 or 0 depending no the bit state
 */
int ldns_get_bit_r(uint8_t bits[], size_t index);

/**
 * sets the specified bit in the specified byte to
 * 1 if value is true, 0 if false
 * The bits are counted from right to left, so bit #0 is the
 * right most bit.
 * \param[in] byte the bit to set the bit in
 * \param[in] bit_nr the bit to set (0 <= n <= 7)
 * \param[in] value whether to set the bit to 1 or 0
 * \return 1 or 0 depending no the bit state
 */
void ldns_set_bit(uint8_t *byte, int bit_nr, bool value);

/**
 * Returns the value of a to the power of b
 * (or 1 of b < 1)
 */
/*@unused@*/
static inline long
ldns_power(long a, long b) {
	long result = 1;
	while (b > 0) {
		if (b & 1) {
			result *= a;
			if (b == 1) {
				return result;
			}
		}
		a *= a;
		b /= 2;
	}
	return result;
}

/**
 * Returns the int value of the given (hex) digit
 * \param[in] ch the hex char to convert
 * \return the converted decimal value
 */
int ldns_hexdigit_to_int(char ch);

/**
 * Returns the char (hex) representation of the given int
 * \param[in] ch the int to convert
 * \return the converted hex char
 */
char ldns_int_to_hexdigit(int ch);

/**
 * Show the internal library version
 * \return a string with the version in it
 */
const char * ldns_version(void);

/**
 * Convert TM to seconds since epoch (midnight, January 1st, 1970).
 * Like timegm(3), which is not always available.
 * \param[in] tm a struct tm* with the date
 * \return the seconds since epoch
 */
time_t mktime_from_utc(const struct tm *tm);

#endif /* !_UTIL_H */
